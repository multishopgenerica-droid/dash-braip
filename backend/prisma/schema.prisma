generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== AUTENTICACAO ====================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String
  role          Role      @default(USER)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLogin     DateTime?

  gateways      GatewayConfig[]
  refreshTokens RefreshToken[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("refresh_tokens")
}

enum Role {
  ADMIN
  USER
  VIEWER
}

// ==================== GATEWAYS ====================

model GatewayConfig {
  id           String      @id @default(cuid())
  userId       String
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  gateway      GatewayType
  apiToken     String
  webhookToken String?     @unique @default(cuid())
  isActive     Boolean     @default(true)
  lastSync     DateTime?
  syncStatus   SyncStatus  @default(PENDING)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  sales        Sale[]
  abandons     Abandon[]
  products     Product[]
  affiliates   Affiliate[]
  webhookLogs  WebhookLog[]

  @@unique([userId, gateway])
  @@map("gateway_configs")
}

enum GatewayType {
  BRAIP
  HOTMART
  EDUZZ
  KIWIFY
  MONETIZZE
}

enum SyncStatus {
  PENDING
  SYNCING
  COMPLETED
  ERROR
}

// ==================== VENDAS ====================

model Sale {
  id                  String        @id @default(cuid())
  gatewayConfigId     String
  gatewayConfig       GatewayConfig @relation(fields: [gatewayConfigId], references: [id], onDelete: Cascade)

  transKey            String
  productKey          String
  planKey             String?

  productName         String
  planName            String?

  transValue          Int
  transTotalValue     Int
  transFreight        Int?
  transFreightType    String?

  transStatus         String
  transStatusCode     Int
  paymentType         Int
  paymentDate         DateTime?

  clientName          String
  clientEmail         String
  clientPhone         String?
  clientDocument      String?
  clientAddress       String?
  clientCity          String?
  clientState         String?
  clientZipCode       String?

  hasOrderBump        Boolean       @default(false)

  trackingCode        String?
  shippingCompany     String?

  commissions         Json?
  commissionsRelease  DateTime?

  items               SaleItem[]

  transCreateDate     DateTime
  transUpdateDate     DateTime
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  @@unique([gatewayConfigId, transKey])
  @@index([transStatusCode])
  @@index([transCreateDate])
  @@index([productKey])
  @@map("sales")
}

model SaleItem {
  id          String  @id @default(cuid())
  saleId      String
  sale        Sale    @relation(fields: [saleId], references: [id], onDelete: Cascade)

  planKey     String
  planName    String
  planValue   Int
  planAmount  Int
  productKey  String
  productType Int
  isMain      Boolean @default(false)

  @@map("sale_items")
}

// ==================== ABANDONOS ====================

model Abandon {
  id              String        @id @default(cuid())
  gatewayConfigId String
  gatewayConfig   GatewayConfig @relation(fields: [gatewayConfigId], references: [id], onDelete: Cascade)

  abandonKey      String?
  productKey      String
  productName     String
  planKey         String?
  planName        String?
  planAmount      Int?

  clientName      String?
  clientEmail     String?
  clientPhone     String?
  clientDocument  String?
  clientAddress   String?
  clientCity      String?
  clientState     String?
  clientZipCode   String?

  transCreateDate DateTime
  transUpdateDate DateTime
  createdAt       DateTime      @default(now())

  @@unique([gatewayConfigId, abandonKey])
  @@index([transCreateDate])
  @@index([productKey])
  @@map("abandons")
}

// ==================== PRODUTOS ====================

model Product {
  id              String        @id @default(cuid())
  gatewayConfigId String
  gatewayConfig   GatewayConfig @relation(fields: [gatewayConfigId], references: [id], onDelete: Cascade)

  productHash     String
  name            String
  description     String?
  thumbnail       String?

  totalSales      Int           @default(0)
  totalRevenue    Int           @default(0)
  totalAbandons   Int           @default(0)
  conversionRate  Float         @default(0)

  plans           Plan[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([gatewayConfigId, productHash])
  @@map("products")
}

model Plan {
  id           String   @id @default(cuid())
  productId    String
  product      Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  planKey      String
  planName     String
  planAmount   Int      @default(0)

  totalSales   Int      @default(0)
  totalRevenue Int      @default(0)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([productId, planKey])
  @@index([productId])
  @@map("plans")
}

// ==================== AFILIADOS ====================

model Affiliate {
  id              String        @id @default(cuid())
  gatewayConfigId String
  gatewayConfig   GatewayConfig @relation(fields: [gatewayConfigId], references: [id], onDelete: Cascade)

  affiliateHash   String
  name            String
  email           String?
  phone           String?
  document        String?

  totalSales      Int           @default(0)
  totalRevenue    Int           @default(0)
  totalCommission Int           @default(0)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([gatewayConfigId, affiliateHash])
  @@index([gatewayConfigId])
  @@map("affiliates")
}

// ==================== ASSINATURAS ====================

model Subscription {
  id              String   @id @default(cuid())
  gatewayConfigId String

  subKey          String
  subStatus       Int
  nextCharge      DateTime?
  nextAttempt     DateTime?
  attempts        Int      @default(0)
  value           Int

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([gatewayConfigId, subKey])
  @@map("subscriptions")
}

// ==================== LOGS E METRICAS ====================

model SyncLog {
  id              String     @id @default(cuid())
  gatewayConfigId String

  startedAt       DateTime   @default(now())
  finishedAt      DateTime?
  status          SyncStatus
  recordsSynced   Int        @default(0)
  errorMessage    String?

  @@map("sync_logs")
}

model DailyMetric {
  id              String   @id @default(cuid())
  gatewayConfigId String
  date            DateTime @db.Date

  totalSales      Int      @default(0)
  approvedSales   Int      @default(0)
  pendingSales    Int      @default(0)
  canceledSales   Int      @default(0)
  chargebacks     Int      @default(0)
  refunds         Int      @default(0)

  totalRevenue    Int      @default(0)
  totalAbandons   Int      @default(0)

  conversionRate  Float    @default(0)

  @@unique([gatewayConfigId, date])
  @@map("daily_metrics")
}

// ==================== AI ANALYSIS ====================

model AiAnalysis {
  id          String           @id @default(cuid())
  userId      String
  title       String
  description String?
  type        AiAnalysisType
  prompt      String           @db.Text
  result      String?          @db.Text
  status      AiAnalysisStatus @default(PENDING)
  metadata    Json?

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([userId])
  @@index([type])
  @@index([status])
  @@map("ai_analyses")
}

enum AiAnalysisType {
  SALES_TREND
  PRODUCT_PERFORMANCE
  CUSTOMER_BEHAVIOR
  CONVERSION_OPTIMIZATION
  ABANDONMENT_ANALYSIS
  REVENUE_FORECAST
  CUSTOM
}

enum AiAnalysisStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ==================== WEBHOOKS ====================

model WebhookLog {
  id              String        @id @default(cuid())
  gatewayConfigId String
  gatewayConfig   GatewayConfig @relation(fields: [gatewayConfigId], references: [id], onDelete: Cascade)

  event           String
  payload         Json
  status          WebhookStatus @default(RECEIVED)
  errorMessage    String?
  processedAt     DateTime?

  createdAt       DateTime      @default(now())

  @@index([gatewayConfigId])
  @@index([status])
  @@index([createdAt])
  @@map("webhook_logs")
}

enum WebhookStatus {
  RECEIVED
  PROCESSED
  FAILED
}

// ==================== TELEGRAM IA ====================

model TelegramConfig {
  id              String   @id @default(cuid())
  userId          String   @unique

  enabled         Boolean  @default(false)
  botToken        String?
  botUsername     String?
  webhookSecret   String?  @default(cuid())

  // Authorized Telegram user IDs (comma-separated)
  authorizedUsers String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  chatLogs        TelegramChatLog[]

  @@map("telegram_configs")
}

model TelegramChatLog {
  id              String   @id @default(cuid())
  telegramConfigId String
  telegramConfig  TelegramConfig @relation(fields: [telegramConfigId], references: [id], onDelete: Cascade)

  chatId          String
  userId          String
  username        String?
  firstName       String?
  messageIn       String   @db.Text
  messageOut      String?  @db.Text
  intent          String?
  queryData       Json?

  processedAt     DateTime?
  createdAt       DateTime @default(now())

  @@index([telegramConfigId])
  @@index([chatId])
  @@index([createdAt])
  @@map("telegram_chat_logs")
}

// ==================== WHATSAPP IA ====================

model WhatsAppConfig {
  id              String   @id @default(cuid())
  userId          String   @unique

  enabled         Boolean  @default(false)
  phoneNumber     String?
  instanceName    String?
  evolutionApiUrl String?
  evolutionApiKey String?

  // Authorized phone numbers that can query (comma-separated)
  authorizedPhones String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  chatLogs        WhatsAppChatLog[]

  @@map("whatsapp_configs")
}

model WhatsAppChatLog {
  id              String   @id @default(cuid())
  whatsappConfigId String
  whatsappConfig  WhatsAppConfig @relation(fields: [whatsappConfigId], references: [id], onDelete: Cascade)

  phoneNumber     String
  messageIn       String   @db.Text
  messageOut      String?  @db.Text
  intent          String?
  queryData       Json?

  processedAt     DateTime?
  createdAt       DateTime @default(now())

  @@index([whatsappConfigId])
  @@index([phoneNumber])
  @@index([createdAt])
  @@map("whatsapp_chat_logs")
}
